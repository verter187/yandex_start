package main

import (
	"fmt"
	"reflect"
)

func find(arr []int, k int) []int {
	// Создадим пустую map
	m := make(map[int]int)
	// будем складывать в неё индексы массива, а в качестве ключей использовать само значение
	for i, a := range arr {
		if j, ok := m[k-a]; ok { // если значение k-a уже есть в массиве, значит, arr[j] + arr[i] = k и мы нашли, то что нужно
			return []int{i, j}
		}
		// если искомого значения нет, то добавляем текущий индекс и значение в map
		m[a] = i
	}
	// не нашли пары подходящих чисел
	return nil
}

// как можно заметить, алгоритм пройдётся по массиву всего один раз
// если бы мы искали подходящее значение каждый раз через перебор массива, то пришлось бы сделать гораздо больше вычислений
func main() {
	m := make(map[string]string)
	m["foo"] = "bar"
	m["ping"] = "pong"
	fmt.Println(m)
	fmt.Println(m["foo"])
	delete(m, "ping")
	fmt.Println(m["ping"])
	fmt.Println(reflect.TypeOf(m["777"])) //Если ключ не найден, то возвращается пустое значение с типом, указанным для value
	v, ok := m["ping"]
	fmt.Println(v, ok)
	m1 := make(map[int]int)
	m1[1] = 1
	m1[2] = 2
	fmt.Println(m1)
	fmt.Println(m1[1])
	m1[2]++
	fmt.Println(m1[2])
	fmt.Println(m1[3]) //Если ключ не найден, то возвращается пустое значение с типом, указанным для value

	// Для ключей должны быть определены операторы == и !=, поэтому ключ не может быть функцией, хеш-таблицей или слайсом.

	// Получить адрес элемента map не получится. Это связано с тем, что при
	// добавлении новых элементов в мапу может произойти перемещение в памяти
	// уже существующих элементов. Указатели на эти элементы станут недействительными.
	// Поэтому такая операция запрещена.
	// addr := &m[k] //cannot take the address of m[k]

	var m2 map[int]int
	m3 := map[int]int{1: 10, 2: 20, 3: 30}
	fmt.Println(len(m2), len(m3))

	var m4 map[string]string
	if m4 != nil { // если не проверить это условие,
		m4["foo"] = "bar" // то здесь можно получить panic
	}

	m5 := make(map[string]string)
	m5["foo"] = "bar"
	m5["bazz"] = "yup"
	for k, v := range m5 {
		// k будет перебирать ключи,
		// v — соответствующие этим ключам значения
		fmt.Printf("Ключ %v, имеет значение %v \n", k, v)

		//  v = "here key "+k //Так работать не будет
		//Нужно так
		m5[k] = "here key " + k
	}
	fmt.Println(m5)
	// Go позволяет добавлять и удалять значения в map прямо внутри цикла, в процессе итерации.
	// Удалённые ключи гарантированно не попадут в последующие итерации.
	// С добавленными ключами таких гарантий нет. Новый ключ может попасть в последующие итерации, а может и не попасть.
	// Такой вариант возможен, но считается плохой практикой:
	for k, _ := range m { // обратите внимание на подчёркивание _
		delete(m, k)
	}

	products := make(map[string]int)
	products["хлеб"] = 50
	products["молоко"] = 100
	products["масло"] = 200
	products["колбаса"] = 500
	products["соль"] = 20
	products["огурцы"] = 200
	products["сыр"] = 600
	products["ветчина"] = 700
	products["буженина"] = 900
	products["помидоры"] = 250
	products["рыба"] = 300
	products["хамон"] = 1500

	for k, v := range products {
		if v > 500 {
			fmt.Println(k)
		}
	}

	order := []string{"хлеб", "буженина", "сыр", "огурцы"}
	total := 0
	for _, v := range order {
		total += products[v]
	}

	fmt.Println(total)

}
